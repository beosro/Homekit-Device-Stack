"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = __importDefault(require("crypto"));
var fs_1 = __importDefault(require("fs"));
var ip_1 = __importDefault(require("ip"));
var child_process_1 = require("child_process");
var Service_1 = require("./Service");
var StreamController_1 = require("./StreamController");
var uuid = __importStar(require("./util/uuid"));
var Camera = /** @class */ (function () {
    function Camera() {
        var _this = this;
        this.services = [];
        this.streamControllers = [];
        this.pendingSessions = {};
        this.ongoingSessions = {};
        this.handleSnapshotRequest = function (request, callback) {
            // Image request: {width: number, height: number}
            // Please override this and invoke callback(error, image buffer) when the snapshot is ready
            var snapshot = fs_1.default.readFileSync(__dirname + '/res/snapshot.jpg');
            callback(undefined, snapshot);
        };
        this.handleCloseConnection = function (connectionID) {
            _this.streamControllers.forEach(function (controller) {
                controller.handleCloseConnection(connectionID);
            });
        };
        this.prepareStream = function (request, callback) {
            // Invoked when iOS device requires stream
            var sessionInfo = {};
            var sessionID = request["sessionID"];
            var targetAddress = request["targetAddress"];
            sessionInfo["address"] = targetAddress;
            var response = {};
            var videoInfo = request["video"];
            if (videoInfo) {
                var targetPort = videoInfo["port"];
                var srtp_key = videoInfo["srtp_key"];
                var srtp_salt = videoInfo["srtp_salt"];
                // SSRC is a 32 bit integer that is unique per stream
                var ssrcSource = crypto_1.default.randomBytes(4);
                ssrcSource[0] = 0;
                var ssrc = ssrcSource.readInt32BE(0);
                var videoResp = {
                    port: targetPort,
                    ssrc: ssrc,
                    srtp_key: srtp_key,
                    srtp_salt: srtp_salt
                };
                response["video"] = videoResp;
                sessionInfo["video_port"] = targetPort;
                sessionInfo["video_srtp"] = Buffer.concat([srtp_key, srtp_salt]);
                sessionInfo["video_ssrc"] = ssrc;
            }
            var audioInfo = request["audio"];
            if (audioInfo) {
                var targetPort = audioInfo["port"];
                var srtp_key = audioInfo["srtp_key"];
                var srtp_salt = audioInfo["srtp_salt"];
                // SSRC is a 32 bit integer that is unique per stream
                var ssrcSource = crypto_1.default.randomBytes(4);
                ssrcSource[0] = 0;
                var ssrc = ssrcSource.readInt32BE(0);
                var audioResp = {
                    port: targetPort,
                    ssrc: ssrc,
                    srtp_key: srtp_key,
                    srtp_salt: srtp_salt
                };
                response["audio"] = audioResp;
                sessionInfo["audio_port"] = targetPort;
                sessionInfo["audio_srtp"] = Buffer.concat([srtp_key, srtp_salt]);
                sessionInfo["audio_ssrc"] = ssrc;
            }
            var currentAddress = ip_1.default.address();
            var addressResp = {
                address: currentAddress
            };
            if (ip_1.default.isV4Format(currentAddress)) {
                addressResp["type"] = "v4";
            }
            else {
                addressResp["type"] = "v6";
            }
            response["address"] = addressResp;
            _this.pendingSessions[uuid.unparse(sessionID)] = sessionInfo;
            callback(response);
        };
        this.handleStreamRequest = function (request) {
            // Invoked when iOS device asks stream to start/stop/reconfigure
            var sessionID = request["sessionID"];
            var requestType = request["type"];
            if (sessionID) {
                var sessionIdentifier = uuid.unparse(sessionID);
                if (requestType == StreamController_1.StreamRequestTypes.START) {
                    var sessionInfo = _this.pendingSessions[sessionIdentifier];
                    if (sessionInfo) {
                        var width = 1280;
                        var height = 720;
                        var fps = 30;
                        var bitrate = 300;
                        var videoInfo = request["video"];
                        if (videoInfo) {
                            width = videoInfo["width"];
                            height = videoInfo["height"];
                            var expectedFPS = videoInfo["fps"];
                            if (expectedFPS < fps) {
                                fps = expectedFPS;
                            }
                            bitrate = videoInfo["max_bit_rate"];
                        }
                        var targetAddress = sessionInfo["address"];
                        var targetVideoPort = sessionInfo["video_port"];
                        var videoKey = sessionInfo["video_srtp"];
                        var videoSsrc = sessionInfo["video_ssrc"];
                        var ffmpegCommand = '-re -f avfoundation -r 29.970000 -i 0:0 -threads 0 -vcodec libx264 -an -pix_fmt yuv420p -r ' + fps + ' -f rawvideo -tune zerolatency -vf scale=' + width + ':' + height + ' -b:v ' + bitrate + 'k -bufsize ' + bitrate + 'k -payload_type 99 -ssrc ' + videoSsrc + ' -f rtp -srtp_out_suite AES_CM_128_HMAC_SHA1_80 -srtp_out_params ' + videoKey.toString('base64') + ' srtp://' + targetAddress + ':' + targetVideoPort + '?rtcpport=' + targetVideoPort + '&localrtcpport=' + targetVideoPort + '&pkt_size=1378';
                        _this.ongoingSessions[sessionIdentifier] = child_process_1.spawn('ffmpeg', ffmpegCommand.split(' '), { env: process.env });
                    }
                    delete _this.pendingSessions[sessionIdentifier];
                }
                else if (requestType == StreamController_1.StreamRequestTypes.STOP) {
                    var ffmpegProcess = _this.ongoingSessions[sessionIdentifier];
                    if (ffmpegProcess) {
                        ffmpegProcess.kill('SIGKILL');
                    }
                    delete _this.ongoingSessions[sessionIdentifier];
                }
            }
        };
        this.createCameraControlService = function () {
            var controlService = new Service_1.Service.CameraControl('', '');
            // Developer can add control characteristics like rotation, night vision at here.
            _this.services.push(controlService);
        };
        this.createSecureVideoService = function () {
            var myCameraOperatingMode = new Service_1.Service.CameraOperatingMode('', '');
            _this.services.push(myCameraOperatingMode);
            var myCameraEventRecordingManagement = new Service_1.Service.CameraEventRecordingManagement('', '');
            _this.services.push(myCameraEventRecordingManagement);
        };
        // Private
        this._createStreamControllers = function (maxStreams, options) {
            for (var i = 0; i < maxStreams; i++) {
                var streamController = new StreamController_1.StreamController(i, options, _this);
                _this.services.push(streamController.service);
                _this.streamControllers.push(streamController);
            }
        };
        var options = {
            proxy: false,
            disable_audio_proxy: false,
            srtp: true,
            video: {
                resolutions: [
                    [1920, 1080, 30],
                    [320, 240, 15],
                    [1280, 960, 30],
                    [1280, 720, 30],
                    [1024, 768, 30],
                    [640, 480, 30],
                    [640, 360, 30],
                    [480, 360, 30],
                    [480, 270, 30],
                    [320, 240, 30],
                    [320, 180, 30],
                ],
                codec: {
                    profiles: [0, 1, 2],
                    levels: [0, 1, 2] // Enum, please refer StreamController.VideoCodecParamLevelTypes
                }
            },
            audio: {
                comfort_noise: false,
                codecs: [
                    {
                        type: "OPUS",
                        samplerate: 24 // 8, 16, 24 KHz
                    },
                    {
                        type: "AAC-eld",
                        samplerate: 16
                    }
                ]
            }
        };
        this.createCameraControlService();
        this.createSecureVideoService();
        this._createStreamControllers(2, options);
    }
    return Camera;
}());
exports.Camera = Camera;
//# sourceMappingURL=Camera.js.map