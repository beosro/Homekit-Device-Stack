/// <reference types="node" />
import { SerializedService, Service } from './Service';
import { Characteristic, CharacteristicSetCallback } from './Characteristic';
import { Advertiser } from './Advertiser';
import { CharacteristicsWriteRequest, HAPServer } from './HAPServer';
import { AccessoryInfo, PairingInformation, PermissionTypes } from './model/AccessoryInfo';
import { IdentifierCache } from './model/IdentifierCache';
import { CharacteristicChange, CharacteristicData, NodeCallback, Nullable, PairingsCallback, ToHAPOptions, VoidCallback, WithUUID } from '../types';
import { Camera } from './Camera';
import { EventEmitter } from './EventEmitter';
import { Session } from "./util/eventedhttp";
export declare enum Categories {
    OTHER = 1,
    BRIDGE = 2,
    FAN = 3,
    GARAGE_DOOR_OPENER = 4,
    LIGHTBULB = 5,
    DOOR_LOCK = 6,
    OUTLET = 7,
    SWITCH = 8,
    THERMOSTAT = 9,
    SENSOR = 10,
    ALARM_SYSTEM = 11,
    SECURITY_SYSTEM = 11,
    DOOR = 12,
    WINDOW = 13,
    WINDOW_COVERING = 14,
    PROGRAMMABLE_SWITCH = 15,
    RANGE_EXTENDER = 16,
    CAMERA = 17,
    IP_CAMERA = 17,
    VIDEO_DOORBELL = 18,
    AIR_PURIFIER = 19,
    AIR_HEATER = 20,
    AIR_CONDITIONER = 21,
    AIR_HUMIDIFIER = 22,
    AIR_DEHUMIDIFIER = 23,
    APPLE_TV = 24,
    HOMEPOD = 25,
    SPEAKER = 26,
    AIRPORT = 27,
    SPRINKLER = 28,
    FAUCET = 29,
    SHOWER_HEAD = 30,
    TELEVISION = 31,
    TARGET_CONTROLLER = 32,
    ROUTER = 33
}
export interface SerializedAccessory {
    displayName: string;
    UUID: string;
    category: Categories;
    services: SerializedService[];
    linkedServices?: Record<string, string[]>;
}
export declare enum AccessoryEventTypes {
    IDENTIFY = "identify",
    LISTENING = "listening",
    SERVICE_CONFIGURATION_CHANGE = "service-configurationChange",
    SERVICE_CHARACTERISTIC_CHANGE = "service-characteristic-change",
    PAIRED = "paired",
    UNPAIRED = "unpaired"
}
declare type Events = {
    identify: (paired: boolean, cb: VoidCallback) => void;
    listening: (port: number) => void;
    "service-configurationChange": VoidCallback;
    "service-characteristic-change": (change: ServiceCharacteristicChange) => void;
    [AccessoryEventTypes.PAIRED]: () => void;
    [AccessoryEventTypes.UNPAIRED]: () => void;
};
/**
 * @deprecated Use AccessoryEventTypes instead
 */
export declare type EventAccessory = "identify" | "listening" | "service-configurationChange" | "service-characteristic-change";
export declare type CharacteristicEvents = Record<string, any>;
export interface PublishInfo {
    username: string;
    pincode: string;
    category?: Categories;
    setupID?: string;
    port?: number;
    mdns?: any;
}
export declare type ServiceCharacteristicChange = CharacteristicChange & {
    accessory: Accessory;
    service: Service;
};
export declare enum ResourceTypes {
    IMAGE = "image"
}
export declare type Resource = {
    'aid'?: number;
    'image-height': number;
    'image-width': number;
    'resource-type': ResourceTypes;
};
/**
 * Accessory is a virtual HomeKit device. It can publish an associated HAP server for iOS devices to communicate
 * with - or it can run behind another "Bridge" Accessory server.
 *
 * Bridged Accessories in this implementation must have a UUID that is unique among all other Accessories that
 * are hosted by the Bridge. This UUID must be "stable" and unchanging, even when the server is restarted. This
 * is required so that the Bridge can provide consistent "Accessory IDs" (aid) and "Instance IDs" (iid) for all
 * Accessories, Services, and Characteristics for iOS clients to reference later.
 *
 * @event 'identify' => function(paired, callback(err)) { }
 *        Emitted when an iOS device wishes for this Accessory to identify itself. If `paired` is false, then
 *        this device is currently browsing for Accessories in the system-provided "Add Accessory" screen. If
 *        `paired` is true, then this is a device that has already paired with us. Note that if `paired` is true,
 *        listening for this event is a shortcut for the underlying mechanism of setting the `Identify` Characteristic:
 *        `getService(Service.AccessoryInformation).getCharacteristic(Characteristic.Identify).on('set', ...)`
 *        You must call the callback for identification to be successful.
 *
 * @event 'service-characteristic-change' => function({service, characteristic, oldValue, newValue, context}) { }
 *        Emitted after a change in the value of one of the provided Service's Characteristics.
 */
export declare class Accessory extends EventEmitter<Events> {
    displayName: string;
    UUID: string;
    static Categories: typeof Categories;
    aid: Nullable<number>;
    _isBridge: boolean;
    bridged: boolean;
    bridge?: Accessory;
    bridgedAccessories: Accessory[];
    reachable: boolean;
    cameraSource: Nullable<Camera>;
    category: Categories;
    services: Service[];
    shouldPurgeUnusedIDs: boolean;
    _accessoryInfo?: Nullable<AccessoryInfo>;
    _setupID: Nullable<string>;
    _identifierCache?: Nullable<IdentifierCache>;
    _advertiser?: Advertiser;
    _server?: HAPServer;
    _setupURI?: string;
    relayServer: any;
    constructor(displayName: string, UUID: string);
    _identificationRequest: (paired: boolean, callback: CharacteristicSetCallback) => void;
    addService: (service: Service | typeof Service, ...constructorArgs: any[]) => Service;
    setPrimaryService: (service: Service) => void;
    removeService: (service: Service) => void;
    getService: <T extends WithUUID<typeof Service>>(name: string | T) => Service | undefined;
    /**
     * Returns the bridging accessory if this accessory is bridged.
     * Otherwise returns itself.
     *
     * @returns the primary accessory
     */
    getPrimaryAccessory: () => Accessory;
    updateReachability: (reachable: boolean) => void;
    addBridgedAccessory: (accessory: Accessory, deferUpdate?: boolean) => Accessory;
    addBridgedAccessories: (accessories: Accessory[]) => void;
    removeBridgedAccessory: (accessory: Accessory, deferUpdate: boolean) => void;
    removeBridgedAccessories: (accessories: Accessory[]) => void;
    removeAllBridgedAccessories: () => void;
    getCharacteristicByIID: (iid: number) => Characteristic | undefined;
    getBridgedAccessoryByAID: (aid: number) => Accessory | undefined;
    findCharacteristic: (aid: number, iid: number) => Characteristic | undefined;
    configureCameraSource: (cameraSource: Camera) => void;
    setupURI: () => string;
    /**
     * Assigns aid/iid to ourselves, any Accessories we are bridging, and all associated Services+Characteristics. Uses
     * the provided identifierCache to keep IDs stable.
     */
    _assignIDs: (identifierCache: IdentifierCache) => void;
    disableUnusedIDPurge: () => void;
    enableUnusedIDPurge: () => void;
    /**
     * Manually purge the unused ids if you like, comes handy
     * when you have disabled auto purge so you can do it manually
     */
    purgeUnusedIDs: () => void;
    /**
     * Returns a JSON representation of this Accessory suitable for delivering to HAP clients.
     */
    toHAP: (opt?: ToHAPOptions | undefined) => {
        aid: number | null;
        services: import("../types").HapService[];
    }[];
    /**
     * Publishes this Accessory on the local network for iOS clients to communicate with.
     *
     * @param {Object} info - Required info for publishing.
     * @param {string} info.username - The "username" (formatted as a MAC address - like "CC:22:3D:E3:CE:F6") of
     *                                this Accessory. Must be globally unique from all Accessories on your local network.
     * @param {string} info.pincode - The 8-digit pincode for clients to use when pairing this Accessory. Must be formatted
     *                               as a string like "031-45-154".
     * @param {string} info.category - One of the values of the Accessory.Category enum, like Accessory.Category.SWITCH.
     *                                This is a hint to iOS clients about what "type" of Accessory this represents, so
     *                                that for instance an appropriate icon can be drawn for the user while adding a
     *                                new Accessory.
     */
    publish: (info: PublishInfo, allowInsecureRequest?: boolean | undefined) => void;
    /**
     * Removes this Accessory from the local network
     * Accessory object will no longer vaild after invoking this method
     * Trying to invoke publish() on the object will result undefined behavior
     */
    destroy: () => void;
    unpublish: () => void;
    _updateConfiguration: () => void;
    _onListening: (port: number) => void;
    _handleIdentify: (callback: VoidCallback) => void;
    _handlePair: (username: string, publicKey: Buffer, callback: VoidCallback) => void;
    _handleAddPairing: (controller: Session, username: string, publicKey: Buffer, permission: PermissionTypes, callback: PairingsCallback<void>) => void;
    _handleRemovePairing: (controller: Session, username: string, callback: PairingsCallback<void>) => void;
    _handleListPairings: (controller: Session, callback: PairingsCallback<PairingInformation[]>) => void;
    _handleAccessories: (callback: NodeCallback<{
        accessories: any[];
    }>) => void;
    _handleGetCharacteristics: (data: CharacteristicData[], events: Record<string, any>, callback: NodeCallback<CharacteristicData[]>, remote: boolean, session: Session) => void;
    _handleSetCharacteristics: (writeRequest: CharacteristicsWriteRequest, events: Record<string, any>, callback: NodeCallback<CharacteristicData[]>, remote: boolean, session: Session) => void;
    _handleResource: (data: Resource, callback: NodeCallback<Buffer>) => void;
    _handleSessionClose: (sessionID: string, events: Record<string, any>) => void;
    _unsubscribeEvents: (events: Record<string, any>) => void;
    _handleCharacteristicChange: (change: ServiceCharacteristicChange) => void;
    _setupService: (service: Service) => void;
    _sideloadServices: (targetServices: Service[]) => void;
    _generateSetupID: () => string;
    static serialize: (accessory: Accessory) => SerializedAccessory;
    static deserialize: (json: SerializedAccessory) => Accessory;
}
export {};
//# sourceMappingURL=Accessory.d.ts.map