/// <reference types="node" />
import { Service } from "./Service";
import { Accessory } from "./Accessory";
import { DataSendCloseReason, DataStreamConnection, DataStreamManagement, DataStreamProtocolHandler, EventHandler, Float32, Int64, RequestHandler } from "./datastream";
import { AudioCodecParamBitRateTypes, AudioCodecParamSampleRateTypes, AudioCodecTypes } from "./StreamController";
import { EventEmitter } from "./EventEmitter";
export declare enum TargetControlCommands {
    MAXIMUM_TARGETS = 1,
    TICKS_PER_SECOND = 2,
    SUPPORTED_BUTTON_CONFIGURATION = 3,
    TYPE = 4
}
export declare enum SupportedButtonConfigurationTypes {
    BUTTON_ID = 1,
    BUTTON_TYPE = 2
}
export declare enum ButtonType {
    UNDEFINED = 0,
    MENU = 1,
    PLAY_PAUSE = 2,
    TV_HOME = 3,
    SELECT = 4,
    ARROW_UP = 5,
    ARROW_RIGHT = 6,
    ARROW_DOWN = 7,
    ARROW_LEFT = 8,
    VOLUME_UP = 9,
    VOLUME_DOWN = 10,
    SIRI = 11,
    POWER = 12,
    GENERIC = 13
}
export declare enum TargetControlList {
    OPERATION = 1,
    TARGET_CONFIGURATION = 2
}
export declare enum Operation {
    UNDEFINED = 0,
    LIST = 1,
    ADD = 2,
    REMOVE = 3,
    RESET = 4,
    UPDATE = 5
}
export declare enum TargetConfigurationTypes {
    TARGET_IDENTIFIER = 1,
    TARGET_NAME = 2,
    TARGET_CATEGORY = 3,
    BUTTON_CONFIGURATION = 4
}
export declare enum TargetCategory {
    UNDEFINED = 0,
    APPLE_TV = 24
}
export declare enum ButtonConfigurationTypes {
    BUTTON_ID = 1,
    BUTTON_TYPE = 2,
    BUTTON_NAME = 3
}
export declare enum ButtonEvent {
    BUTTON_ID = 1,
    BUTTON_STATE = 2,
    TIMESTAMP = 3,
    ACTIVE_IDENTIFIER = 4
}
export declare enum ButtonState {
    UP = 0,
    DOWN = 1
}
export declare type SupportedConfiguration = {
    maximumTargets: number;
    ticksPerSecond: number;
    supportedButtonConfiguration: SupportedButtonConfiguration[];
    hardwareImplemented: boolean;
};
export declare type SupportedButtonConfiguration = {
    buttonID: number;
    buttonType: ButtonType;
};
export declare type TargetConfiguration = {
    targetIdentifier: number;
    targetName?: string;
    targetCategory?: TargetCategory;
    buttonConfiguration: Record<number, ButtonConfiguration>;
};
export declare type ButtonConfiguration = {
    buttonID: number;
    buttonType: ButtonType;
    buttonName?: string;
};
export declare enum SiriInputType {
    PUSH_BUTTON_TRIGGERED_APPLE_TV = 0
}
export declare enum SupportedAudioStreamConfigurationTypes {
    AUDIO_CODEC_CONFIGURATION = 1,
    COMFORT_NOISE_SUPPORT = 2
}
export declare enum SelectedAudioInputStreamConfigurationTypes {
    SELECTED_AUDIO_INPUT_STREAM_CONFIGURATION = 1
}
export declare type SupportedAudioStreamConfiguration = {
    audioCodecConfiguration: AudioCodecConfiguration;
};
export declare type SelectedAudioStreamConfiguration = {
    audioCodecConfiguration: AudioCodecConfiguration;
};
export declare type AudioCodecConfiguration = {
    codecType: AudioCodecTypes;
    parameters: AudioCodecParameters;
};
export declare type AudioCodecParameters = {
    channels: number;
    bitrate: AudioCodecParamBitRateTypes;
    samplerate: AudioCodecParamSampleRateTypes;
    rtpTime?: RTPTime;
};
export declare type RTPTime = 20 | 30 | 40 | 60;
export declare enum SiriAudioSessionState {
    STARTING = 0,
    SENDING = 1,
    CLOSING = 2,
    CLOSED = 3
}
export declare type DataSendMessageData = {
    packets: AudioFramePacket[];
    streamId: Int64;
    endOfStream: boolean;
};
export declare type AudioFrame = {
    data: Buffer;
    rms: number;
};
export declare type AudioFramePacket = {
    data: Buffer;
    metadata: {
        rms: Float32;
        sequenceNumber: Int64;
    };
};
export declare type FrameHandler = (frame: AudioFrame) => void;
export declare type ErrorHandler = (error: DataSendCloseReason) => void;
export interface SiriAudioStreamProducer {
    startAudioProduction(selectedAudioConfiguration: AudioCodecConfiguration): void;
    stopAudioProduction(): void;
}
export interface SiriAudioStreamProducerConstructor {
    /**
     * Creates a new instance of a SiriAudioStreamProducer
     *
     * @param frameHandler {FrameHandler} - called for every opus frame recorded
     * @param errorHandler {ErrorHandler} - should be called with a appropriate reason when the producing process errored
     * @param options - optional parameter for passing any configuration related options
     */
    new (frameHandler: FrameHandler, errorHandler: ErrorHandler, options?: any): SiriAudioStreamProducer;
}
export declare enum RemoteControllerEvents {
    ACTIVE_CHANGE = "active-change",
    ACTIVE_IDENTIFIER_CHANGE = "active-identifier-change",
    TARGET_ADDED = "target-add",
    TARGET_UPDATED = "target-update",
    TARGET_REMOVED = "target-remove",
    TARGETS_RESET = "targets-reset"
}
export declare enum TargetUpdates {
    NAME = 0,
    CATEGORY = 1,
    UPDATED_BUTTONS = 2,
    REMOVED_BUTTONS = 3
}
export declare type RemoteControllerEventMap = {
    [RemoteControllerEvents.ACTIVE_CHANGE]: (active: boolean) => void;
    [RemoteControllerEvents.ACTIVE_IDENTIFIER_CHANGE]: (activeIdentifier: number) => void;
    [RemoteControllerEvents.TARGET_ADDED]: (targetConfiguration: TargetConfiguration) => void;
    [RemoteControllerEvents.TARGET_UPDATED]: (targetConfiguration: TargetConfiguration, updates: TargetUpdates[]) => void;
    [RemoteControllerEvents.TARGET_REMOVED]: (targetIdentifier: number) => void;
    [RemoteControllerEvents.TARGETS_RESET]: () => void;
};
/**
 * Handles everything need to implement a fully working HomeKit remote controller.
 *
 * @event 'active-change': (active: boolean) => void
 *        This event is emitted when the active state of the remote has changed.
 *        active = true indicates that there is currently an apple tv listening of button presses and audio streams.
 *
 * @event 'active-identifier-change': (activeIdentifier: number) => void
 *        This event is emitted when the currently selected target has changed.
 *        Possible reasons for a changed active identifier: manual change via api call, first target configuration
 *        gets added, active target gets removed, accessory gets unpaired, reset request was sent.
 *        An activeIdentifier of 0 indicates that no target is selected.
 *
 *
 * @event 'target-add': (targetConfiguration: TargetConfiguration) => void
 *        This event is emitted when a new target configuration is received. As we currently do not persistently store
 *        configured targets, this will be called at every startup for every Apple TV configured in the home.
 *
 * @event 'target-update': (targetConfiguration: TargetConfiguration, updates: TargetUpdates[]) => void
 *        This event is emitted when a existing target was updated.
 *        The 'updates' array indicates what exactly was changed for the target.
 *
 * @event 'target-remove': (targetIdentifier: number) => void
 *        This event is emitted when a existing configuration for a target was removed.
 *
 * @event 'targets-reset': () => void
 *        This event is emitted when a reset of the target configuration is requested.
 *        With this event every configuration made should be reset. This event is also called
 *        when the accessory gets unpaired.
 */
export declare class HomeKitRemoteController extends EventEmitter<RemoteControllerEventMap> implements DataStreamProtocolHandler {
    audioSupported: boolean;
    audioProducerConstructor?: SiriAudioStreamProducerConstructor;
    audioProducerOptions?: any;
    accessoryConfigured: boolean;
    targetControlManagementService?: Service;
    targetControlService?: Service;
    siriService?: Service;
    audioStreamManagementService?: Service;
    dataStreamManagement?: DataStreamManagement;
    private buttons;
    private readonly supportedConfiguration;
    targetConfigurations: Record<number, TargetConfiguration>;
    private targetConfigurationsString;
    private lastButtonEvent;
    activeIdentifier: number;
    private activeSession?;
    private activeSessionDisconnectionListener?;
    supportedAudioConfiguration: string;
    selectedAudioConfiguration: AudioCodecConfiguration;
    selectedAudioConfigurationString: string;
    dataStreamConnections: Record<number, DataStreamConnection>;
    activeAudioSession?: SiriAudioSession;
    nextAudioSession?: SiriAudioSession;
    eventHandler?: Record<string, EventHandler>;
    requestHandler?: Record<string, RequestHandler>;
    /**
     * Creates a new HomeKitRemoteController.
     * If siri voice input is supported the constructor to an SiriAudioStreamProducer needs to be supplied.
     * Otherwise a remote without voice support will be created.
     *
     * For every audio session a new SiriAudioStreamProducer will be constructed.
     *
     * @param audioProducerConstructor {SiriAudioStreamProducerConstructor} - constructor for a SiriAudioStreamProducer
     * @param producerOptions - if supplied this argument will be supplied as third argument of the SiriAudioStreamProducer
     *                          constructor. This should be used to supply configurations to the stream producer.
     */
    constructor(audioProducerConstructor?: SiriAudioStreamProducerConstructor, producerOptions?: any);
    /**
     * Set a new target as active target. A value of 0 indicates that no target is selected currently.
     *
     * @param activeIdentifier {number} - target identifier
     */
    setActiveIdentifier: (activeIdentifier: number) => void;
    /**
     * @returns if the current target is active, meaning the active device is listening for button events or audio sessions
     */
    isActive: () => boolean;
    /**
     * Checks if the supplied targetIdentifier is configured.
     *
     * @param targetIdentifier {number}
     */
    isConfigured: (targetIdentifier: number) => boolean;
    /**
     * Returns the targetIdentifier for a give device name
     *
     * @param name {string} - the name of the device
     * @returns the targetIdentifier of the device or undefined if not existent
     */
    getTargetIdentifierByName: (name: string) => number | undefined;
    /**
     * Sends a button event to press the supplied button.
     *
     * @param button {ButtonType} - button to be pressed
     */
    pushButton: (button: ButtonType) => void;
    /**
     * Sends a button event that the supplied button was released.
     *
     * @param button {ButtonType} - button which was released
     */
    releaseButton: (button: ButtonType) => void;
    /**
     * Presses a supplied button for a given time.
     *
     * @param button {ButtonType} - button to be pressed and released
     * @param time {number} - time in milliseconds (defaults to 200ms)
     */
    pushAndReleaseButton: (button: ButtonType, time?: number) => void;
    /**
     * This method adds and configures the remote services for a give accessory.
     *
     * @param accessory {Accessory} - the give accessory this remote should be added to
     */
    addServicesToAccessory: (accessory: Accessory) => void;
    constructSupportedConfiguration: () => SupportedConfiguration;
    constructSupportedAudioConfiguration: () => SupportedAudioStreamConfiguration;
    private handleTargetControlWrite;
    private handleAddTarget;
    private handleUpdateTarget;
    private handleRemoveTarget;
    private handleResetTargets;
    private handleListTargets;
    private handleActiveWrite;
    private setInactive;
    private handleActiveSessionDisconnected;
    private sendButtonEvent;
    private parseTargetConfigurationTLV;
    private buildTargetConfigurationsTLV;
    private buildTargetControlSupportedConfigurationTLV;
    private handleTargetControlWhoAmI;
    private handleSiriAudioStart;
    private handleSiriAudioStop;
    private handleDataSendAckEvent;
    private handleDataSendCloseEvent;
    private handleSiriAudioSessionClosed;
    private handleDataStreamConnectionClosed;
    private handleSelectedAudioConfigurationWrite;
    private buildSupportedAudioConfigurationTLV;
    private buildSelectedAudioConfigurationTLV;
    private buildCodecConfigurationTLV;
    _createServices: () => void;
}
export declare enum SiriAudioSessionEvents {
    CLOSE = "close"
}
export declare type SiriAudioSessionEventMap = {
    [SiriAudioSessionEvents.CLOSE]: () => void;
};
/**
 * Represents an ongoing audio transmission
 */
export declare class SiriAudioSession extends EventEmitter<SiriAudioSessionEventMap> {
    readonly connection: DataStreamConnection;
    private readonly selectedAudioConfiguration;
    private readonly producer;
    private producerRunning;
    private producerTimer?;
    state: SiriAudioSessionState;
    streamId?: number;
    endOfStream: boolean;
    private audioFrameQueue;
    private readonly maxQueueSize;
    private sequenceNumber;
    private readonly closeListener;
    constructor(connection: DataStreamConnection, selectedAudioConfiguration: AudioCodecConfiguration, producerConstructor: SiriAudioStreamProducerConstructor, producerOptions?: any);
    /**
     * Called when siri button is pressed
     */
    start(): void;
    /**
     * @returns if the audio session is closing
     */
    isClosing(): boolean;
    /**
     * Called when siri button is released (or active identifier is changed to another device)
     */
    stop(): void;
    private startAudioProducer;
    private stopAudioProducer;
    private handleSiriAudioFrame;
    private handleProducerError;
    handleDataSendAckEvent: (endOfStream: boolean) => void;
    handleDataSendCloseEvent: (reason: DataSendCloseReason) => void;
    private sendDataSendCloseEvent;
    private handleDataStreamConnectionClosed;
    private closed;
    private popSome;
}
//# sourceMappingURL=HomeKitRemoteController.d.ts.map