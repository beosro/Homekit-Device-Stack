"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = __importDefault(require("crypto"));
var debug_1 = __importDefault(require("debug"));
var uuid = __importStar(require("./util/uuid"));
var clone_1 = require("./util/clone");
var Service_1 = require("./Service");
var Characteristic_1 = require("./Characteristic");
var Advertiser_1 = require("./Advertiser");
var HAPServer_1 = require("./HAPServer");
var AccessoryInfo_1 = require("./model/AccessoryInfo");
var IdentifierCache_1 = require("./model/IdentifierCache");
var EventEmitter_1 = require("./EventEmitter");
// var HomeKitTypes = require('./gen/HomeKitTypes');
// var RelayServer = require("./util/relayserver").RelayServer;
var debug = debug_1.default('Accessory');
var MAX_ACCESSORIES = 149; // Maximum number of bridged accessories per bridge.
// Known category values. Category is a hint to iOS clients about what "type" of Accessory this represents, for UI only.
var Categories;
(function (Categories) {
    Categories[Categories["OTHER"] = 1] = "OTHER";
    Categories[Categories["BRIDGE"] = 2] = "BRIDGE";
    Categories[Categories["FAN"] = 3] = "FAN";
    Categories[Categories["GARAGE_DOOR_OPENER"] = 4] = "GARAGE_DOOR_OPENER";
    Categories[Categories["LIGHTBULB"] = 5] = "LIGHTBULB";
    Categories[Categories["DOOR_LOCK"] = 6] = "DOOR_LOCK";
    Categories[Categories["OUTLET"] = 7] = "OUTLET";
    Categories[Categories["SWITCH"] = 8] = "SWITCH";
    Categories[Categories["THERMOSTAT"] = 9] = "THERMOSTAT";
    Categories[Categories["SENSOR"] = 10] = "SENSOR";
    Categories[Categories["ALARM_SYSTEM"] = 11] = "ALARM_SYSTEM";
    Categories[Categories["SECURITY_SYSTEM"] = 11] = "SECURITY_SYSTEM";
    Categories[Categories["DOOR"] = 12] = "DOOR";
    Categories[Categories["WINDOW"] = 13] = "WINDOW";
    Categories[Categories["WINDOW_COVERING"] = 14] = "WINDOW_COVERING";
    Categories[Categories["PROGRAMMABLE_SWITCH"] = 15] = "PROGRAMMABLE_SWITCH";
    Categories[Categories["RANGE_EXTENDER"] = 16] = "RANGE_EXTENDER";
    Categories[Categories["CAMERA"] = 17] = "CAMERA";
    Categories[Categories["IP_CAMERA"] = 17] = "IP_CAMERA";
    Categories[Categories["VIDEO_DOORBELL"] = 18] = "VIDEO_DOORBELL";
    Categories[Categories["AIR_PURIFIER"] = 19] = "AIR_PURIFIER";
    Categories[Categories["AIR_HEATER"] = 20] = "AIR_HEATER";
    Categories[Categories["AIR_CONDITIONER"] = 21] = "AIR_CONDITIONER";
    Categories[Categories["AIR_HUMIDIFIER"] = 22] = "AIR_HUMIDIFIER";
    Categories[Categories["AIR_DEHUMIDIFIER"] = 23] = "AIR_DEHUMIDIFIER";
    Categories[Categories["APPLE_TV"] = 24] = "APPLE_TV";
    Categories[Categories["HOMEPOD"] = 25] = "HOMEPOD";
    Categories[Categories["SPEAKER"] = 26] = "SPEAKER";
    Categories[Categories["AIRPORT"] = 27] = "AIRPORT";
    Categories[Categories["SPRINKLER"] = 28] = "SPRINKLER";
    Categories[Categories["FAUCET"] = 29] = "FAUCET";
    Categories[Categories["SHOWER_HEAD"] = 30] = "SHOWER_HEAD";
    Categories[Categories["TELEVISION"] = 31] = "TELEVISION";
    Categories[Categories["TARGET_CONTROLLER"] = 32] = "TARGET_CONTROLLER";
    Categories[Categories["ROUTER"] = 33] = "ROUTER"; // HomeKit enabled router
})(Categories = exports.Categories || (exports.Categories = {}));
var AccessoryEventTypes;
(function (AccessoryEventTypes) {
    AccessoryEventTypes["IDENTIFY"] = "identify";
    AccessoryEventTypes["LISTENING"] = "listening";
    AccessoryEventTypes["SERVICE_CONFIGURATION_CHANGE"] = "service-configurationChange";
    AccessoryEventTypes["SERVICE_CHARACTERISTIC_CHANGE"] = "service-characteristic-change";
    AccessoryEventTypes["PAIRED"] = "paired";
    AccessoryEventTypes["UNPAIRED"] = "unpaired";
})(AccessoryEventTypes = exports.AccessoryEventTypes || (exports.AccessoryEventTypes = {}));
var ResourceTypes;
(function (ResourceTypes) {
    ResourceTypes["IMAGE"] = "image";
})(ResourceTypes = exports.ResourceTypes || (exports.ResourceTypes = {}));
var WriteRequestState;
(function (WriteRequestState) {
    WriteRequestState[WriteRequestState["REGULAR_REQUEST"] = 0] = "REGULAR_REQUEST";
    WriteRequestState[WriteRequestState["TIMED_WRITE_AUTHENTICATED"] = 1] = "TIMED_WRITE_AUTHENTICATED";
    WriteRequestState[WriteRequestState["TIMED_WRITE_REJECTED"] = 2] = "TIMED_WRITE_REJECTED";
})(WriteRequestState || (WriteRequestState = {}));
/**
 * Accessory is a virtual HomeKit device. It can publish an associated HAP server for iOS devices to communicate
 * with - or it can run behind another "Bridge" Accessory server.
 *
 * Bridged Accessories in this implementation must have a UUID that is unique among all other Accessories that
 * are hosted by the Bridge. This UUID must be "stable" and unchanging, even when the server is restarted. This
 * is required so that the Bridge can provide consistent "Accessory IDs" (aid) and "Instance IDs" (iid) for all
 * Accessories, Services, and Characteristics for iOS clients to reference later.
 *
 * @event 'identify' => function(paired, callback(err)) { }
 *        Emitted when an iOS device wishes for this Accessory to identify itself. If `paired` is false, then
 *        this device is currently browsing for Accessories in the system-provided "Add Accessory" screen. If
 *        `paired` is true, then this is a device that has already paired with us. Note that if `paired` is true,
 *        listening for this event is a shortcut for the underlying mechanism of setting the `Identify` Characteristic:
 *        `getService(Service.AccessoryInformation).getCharacteristic(Characteristic.Identify).on('set', ...)`
 *        You must call the callback for identification to be successful.
 *
 * @event 'service-characteristic-change' => function({service, characteristic, oldValue, newValue, context}) { }
 *        Emitted after a change in the value of one of the provided Service's Characteristics.
 */
var Accessory = /** @class */ (function (_super) {
    __extends(Accessory, _super);
    function Accessory(displayName, UUID) {
        var _this = _super.call(this) || this;
        _this.displayName = displayName;
        _this.UUID = UUID;
        // NOTICE: when adding/changing properties, remember to possibly adjust the serialize/deserialize functions
        _this.aid = null; // assigned by us in assignIDs() or by a Bridge
        _this._isBridge = false; // true if we are a Bridge (creating a new instance of the Bridge subclass sets this to true)
        _this.bridged = false; // true if we are hosted "behind" a Bridge Accessory
        _this.bridgedAccessories = []; // If we are a Bridge, these are the Accessories we are bridging
        _this.reachable = true;
        _this.cameraSource = null;
        _this.category = Categories.OTHER;
        _this.services = [];
        _this.shouldPurgeUnusedIDs = true; // Purge unused ids by default
        _this._setupID = null;
        _this._identificationRequest = function (paired, callback) {
            debug("[%s] Identification request", _this.displayName);
            if (_this.listeners(AccessoryEventTypes.IDENTIFY).length > 0) {
                // allow implementors to identify this Accessory in whatever way is appropriate, and pass along
                // the standard callback for completion.
                _this.emit(AccessoryEventTypes.IDENTIFY, paired, callback);
            }
            else {
                debug("[%s] Identification request ignored; no listeners to 'identify' event", _this.displayName);
                callback();
            }
        };
        _this.addService = function (service) {
            var constructorArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                constructorArgs[_i - 1] = arguments[_i];
            }
            // service might be a constructor like `Service.AccessoryInformation` instead of an instance
            // of Service. Coerce if necessary.
            if (typeof service === 'function')
                service = new service(constructorArgs[0], constructorArgs[1], constructorArgs[2]);
            // service = new (Function.prototype.bind.apply(service, arguments));
            // check for UUID+subtype conflict
            for (var index in _this.services) {
                var existing = _this.services[index];
                if (existing.UUID === service.UUID) {
                    // OK we have two Services with the same UUID. Check that each defines a `subtype` property and that each is unique.
                    if (!service.subtype)
                        throw new Error("Cannot add a Service with the same UUID '" + existing.UUID + "' as another Service in this Accessory without also defining a unique 'subtype' property.");
                    if (service.subtype.toString() === existing.subtype.toString())
                        throw new Error("Cannot add a Service with the same UUID '" + existing.UUID + "' and subtype '" + existing.subtype + "' as another Service in this Accessory.");
                }
            }
            _this.services.push(service);
            if (!_this.bridged) {
                _this._updateConfiguration();
            }
            else {
                _this.emit(AccessoryEventTypes.SERVICE_CONFIGURATION_CHANGE, clone_1.clone({ accessory: _this, service: service }));
            }
            service.on(Service_1.ServiceEventTypes.SERVICE_CONFIGURATION_CHANGE, function (change) {
                if (!_this.bridged) {
                    _this._updateConfiguration();
                }
                else {
                    _this.emit(AccessoryEventTypes.SERVICE_CONFIGURATION_CHANGE, clone_1.clone({ accessory: _this, service: service }));
                }
            });
            // listen for changes in characteristics and bubble them up
            service.on(Service_1.ServiceEventTypes.CHARACTERISTIC_CHANGE, function (change) {
                _this.emit(AccessoryEventTypes.SERVICE_CHARACTERISTIC_CHANGE, clone_1.clone(change, { service: service }));
                // if we're not bridged, when we'll want to process this event through our HAPServer
                if (!_this.bridged)
                    _this._handleCharacteristicChange(clone_1.clone(change, { accessory: _this, service: service }));
            });
            return service;
        };
        _this.setPrimaryService = function (service) {
            //find this service in the services list
            var targetServiceIndex, existingService;
            for (var index in _this.services) {
                existingService = _this.services[index];
                if (existingService === service) {
                    targetServiceIndex = index;
                    break;
                }
            }
            if (targetServiceIndex) {
                //If the service is found, set isPrimaryService to false for everything.
                for (var index in _this.services)
                    _this.services[index].isPrimaryService = false;
                //Make this service the primary
                existingService.isPrimaryService = true;
                if (!_this.bridged) {
                    _this._updateConfiguration();
                }
                else {
                    _this.emit(AccessoryEventTypes.SERVICE_CONFIGURATION_CHANGE, clone_1.clone({ accessory: _this, service: service }));
                }
            }
        };
        _this.removeService = function (service) {
            var targetServiceIndex = undefined;
            for (var index in _this.services) {
                var existingService = _this.services[index];
                if (existingService === service) {
                    targetServiceIndex = Number.parseInt(index);
                    break;
                }
            }
            if (targetServiceIndex) {
                _this.services.splice(targetServiceIndex, 1);
                if (!_this.bridged) {
                    _this._updateConfiguration();
                }
                else {
                    _this.emit(AccessoryEventTypes.SERVICE_CONFIGURATION_CHANGE, clone_1.clone({ accessory: _this, service: service }));
                }
                service.removeAllListeners();
            }
        };
        _this.getService = function (name) {
            for (var index in _this.services) {
                var service = _this.services[index];
                if (typeof name === 'string' && (service.displayName === name || service.name === name || service.subtype === name))
                    return service;
                else if (typeof name === 'function' && ((service instanceof name) || (name.UUID === service.UUID)))
                    return service;
            }
        };
        /**
         * Returns the bridging accessory if this accessory is bridged.
         * Otherwise returns itself.
         *
         * @returns the primary accessory
         */
        _this.getPrimaryAccessory = function () {
            return _this.bridged ? _this.bridge : _this;
        };
        _this.updateReachability = function (reachable) {
            if (!_this.bridged)
                throw new Error("Cannot update reachability on non-bridged accessory!");
            _this.reachable = reachable;
            debug('Reachability update is no longer being supported.');
        };
        _this.addBridgedAccessory = function (accessory, deferUpdate) {
            if (deferUpdate === void 0) { deferUpdate = false; }
            if (accessory._isBridge)
                throw new Error("Cannot Bridge another Bridge!");
            // check for UUID conflict
            for (var index in _this.bridgedAccessories) {
                var existing = _this.bridgedAccessories[index];
                if (existing.UUID === accessory.UUID)
                    throw new Error("Cannot add a bridged Accessory with the same UUID as another bridged Accessory: " + existing.UUID);
            }
            // A bridge too far...
            if (_this.bridgedAccessories.length >= MAX_ACCESSORIES) {
                throw new Error("Cannot Bridge more than " + MAX_ACCESSORIES + " Accessories");
            }
            // listen for changes in ANY characteristics of ANY services on this Accessory
            accessory.on(AccessoryEventTypes.SERVICE_CHARACTERISTIC_CHANGE, function (change) {
                _this._handleCharacteristicChange(clone_1.clone(change, { accessory: accessory }));
            });
            accessory.on(AccessoryEventTypes.SERVICE_CONFIGURATION_CHANGE, function () {
                _this._updateConfiguration();
            });
            accessory.bridged = true;
            accessory.bridge = _this;
            _this.bridgedAccessories.push(accessory);
            if (!deferUpdate) {
                _this._updateConfiguration();
            }
            return accessory;
        };
        _this.addBridgedAccessories = function (accessories) {
            for (var index in accessories) {
                var accessory = accessories[index];
                _this.addBridgedAccessory(accessory, true);
            }
            _this._updateConfiguration();
        };
        _this.removeBridgedAccessory = function (accessory, deferUpdate) {
            if (accessory._isBridge)
                throw new Error("Cannot Bridge another Bridge!");
            var foundMatchAccessory = false;
            // check for UUID conflict
            for (var index in _this.bridgedAccessories) {
                var existing = _this.bridgedAccessories[index];
                if (existing.UUID === accessory.UUID) {
                    foundMatchAccessory = true;
                    _this.bridgedAccessories.splice(Number.parseInt(index), 1);
                    break;
                }
            }
            if (!foundMatchAccessory)
                throw new Error("Cannot find the bridged Accessory to remove.");
            accessory.removeAllListeners();
            if (!deferUpdate) {
                _this._updateConfiguration();
            }
        };
        _this.removeBridgedAccessories = function (accessories) {
            for (var index in accessories) {
                var accessory = accessories[index];
                _this.removeBridgedAccessory(accessory, true);
            }
            _this._updateConfiguration();
        };
        _this.removeAllBridgedAccessories = function () {
            for (var i = _this.bridgedAccessories.length - 1; i >= 0; i--) {
                _this.removeBridgedAccessory(_this.bridgedAccessories[i], true);
            }
            _this._updateConfiguration();
        };
        _this.getCharacteristicByIID = function (iid) {
            for (var index in _this.services) {
                var service = _this.services[index];
                var characteristic = service.getCharacteristicByIID(iid);
                if (characteristic)
                    return characteristic;
            }
        };
        _this.getBridgedAccessoryByAID = function (aid) {
            for (var index in _this.bridgedAccessories) {
                var accessory = _this.bridgedAccessories[index];
                if (accessory.aid === aid)
                    return accessory;
            }
        };
        _this.findCharacteristic = function (aid, iid) {
            // if aid === 1, the accessory is us (because we are the server), otherwise find it among our bridged
            // accessories (if any)
            var accessory = (aid === 1) ? _this : _this.getBridgedAccessoryByAID(aid);
            return accessory && accessory.getCharacteristicByIID(iid);
        };
        _this.configureCameraSource = function (cameraSource) {
            _this.cameraSource = cameraSource;
            for (var index in cameraSource.services) {
                var service = cameraSource.services[index];
                _this.addService(service);
            }
        };
        _this.setupURI = function () {
            if (_this._setupURI) {
                return _this._setupURI;
            }
            var buffer = Buffer.alloc(8);
            var setupCode = _this._accessoryInfo && parseInt(_this._accessoryInfo.pincode.replace(/-/g, ''), 10);
            var value_low = setupCode;
            var value_high = _this._accessoryInfo && _this._accessoryInfo.category >> 1;
            value_low |= 1 << 28; // Supports IP;
            buffer.writeUInt32BE(value_low, 4);
            if (_this._accessoryInfo && _this._accessoryInfo.category & 1) {
                buffer[4] = buffer[4] | 1 << 7;
            }
            buffer.writeUInt32BE(value_high, 0);
            var encodedPayload = (buffer.readUInt32BE(4) + (buffer.readUInt32BE(0) * Math.pow(2, 32))).toString(36).toUpperCase();
            if (encodedPayload.length != 9) {
                for (var i = 0; i <= 9 - encodedPayload.length; i++) {
                    encodedPayload = "0" + encodedPayload;
                }
            }
            _this._setupURI = "X-HM://" + encodedPayload + _this._setupID;
            return _this._setupURI;
        };
        /**
         * Assigns aid/iid to ourselves, any Accessories we are bridging, and all associated Services+Characteristics. Uses
         * the provided identifierCache to keep IDs stable.
         */
        _this._assignIDs = function (identifierCache) {
            // if we are responsible for our own identifierCache, start the expiration process
            // also check weather we want to have an expiration process
            if (_this._identifierCache && _this.shouldPurgeUnusedIDs) {
                _this._identifierCache.startTrackingUsage();
            }
            if (_this.bridged) {
                // This Accessory is bridged, so it must have an aid > 1. Use the provided identifierCache to
                // fetch or assign one based on our UUID.
                _this.aid = identifierCache.getAID(_this.UUID);
            }
            else {
                // Since this Accessory is the server (as opposed to any Accessories that may be bridged behind us),
                // we must have aid = 1
                _this.aid = 1;
            }
            for (var index in _this.services) {
                var service = _this.services[index];
                if (_this._isBridge) {
                    service._assignIDs(identifierCache, _this.UUID, 2000000000);
                }
                else {
                    service._assignIDs(identifierCache, _this.UUID);
                }
            }
            // now assign IDs for any Accessories we are bridging
            for (var index in _this.bridgedAccessories) {
                var accessory = _this.bridgedAccessories[index];
                accessory._assignIDs(identifierCache);
            }
            // expire any now-unused cache keys (for Accessories, Services, or Characteristics
            // that have been removed since the last call to assignIDs())
            if (_this._identifierCache) {
                //Check weather we want to purge the unused ids
                if (_this.shouldPurgeUnusedIDs)
                    _this._identifierCache.stopTrackingUsageAndExpireUnused();
                //Save in case we have new ones
                _this._identifierCache.save();
            }
        };
        _this.disableUnusedIDPurge = function () {
            _this.shouldPurgeUnusedIDs = false;
        };
        _this.enableUnusedIDPurge = function () {
            _this.shouldPurgeUnusedIDs = true;
        };
        /**
         * Manually purge the unused ids if you like, comes handy
         * when you have disabled auto purge so you can do it manually
         */
        _this.purgeUnusedIDs = function () {
            //Cache the state of the purge mechanisam and set it to true
            var oldValue = _this.shouldPurgeUnusedIDs;
            _this.shouldPurgeUnusedIDs = true;
            //Reassign all ids
            _this._assignIDs(_this._identifierCache);
            //Revert back the purge mechanisam state
            _this.shouldPurgeUnusedIDs = oldValue;
        };
        /**
         * Returns a JSON representation of this Accessory suitable for delivering to HAP clients.
         */
        _this.toHAP = function (opt) {
            var servicesHAP = [];
            for (var index in _this.services) {
                var service = _this.services[index];
                servicesHAP.push(service.toHAP(opt));
            }
            var accessoriesHAP = [{
                    aid: _this.aid,
                    services: servicesHAP
                }];
            // now add any Accessories we are bridging
            for (var index in _this.bridgedAccessories) {
                var accessory = _this.bridgedAccessories[index];
                var bridgedAccessoryHAP = accessory.toHAP(opt);
                // bridgedAccessoryHAP is an array of accessories with one item - extract it
                // and add it to our own array
                accessoriesHAP.push(bridgedAccessoryHAP[0]);
            }
            return accessoriesHAP;
        };
        /**
         * Publishes this Accessory on the local network for iOS clients to communicate with.
         *
         * @param {Object} info - Required info for publishing.
         * @param {string} info.username - The "username" (formatted as a MAC address - like "CC:22:3D:E3:CE:F6") of
         *                                this Accessory. Must be globally unique from all Accessories on your local network.
         * @param {string} info.pincode - The 8-digit pincode for clients to use when pairing this Accessory. Must be formatted
         *                               as a string like "031-45-154".
         * @param {string} info.category - One of the values of the Accessory.Category enum, like Accessory.Category.SWITCH.
         *                                This is a hint to iOS clients about what "type" of Accessory this represents, so
         *                                that for instance an appropriate icon can be drawn for the user while adding a
         *                                new Accessory.
         */
        _this.publish = function (info, allowInsecureRequest) {
            var service;
            service = _this.getService(Service_1.Service.ProtocolInformation);
            if (!service) {
                service = _this.addService(Service_1.Service.ProtocolInformation); // add the protocol information service to the primary accessory
            }
            service.setCharacteristic(Characteristic_1.Characteristic.Version, Advertiser_1.Advertiser.protocolVersionService);
            // attempt to load existing AccessoryInfo from disk
            _this._accessoryInfo = AccessoryInfo_1.AccessoryInfo.load(info.username);
            // if we don't have one, create a new one.
            if (!_this._accessoryInfo) {
                debug("[%s] Creating new AccessoryInfo for our HAP server", _this.displayName);
                _this._accessoryInfo = AccessoryInfo_1.AccessoryInfo.create(info.username);
            }
            if (info.setupID) {
                _this._setupID = info.setupID;
            }
            else if (_this._accessoryInfo.setupID === undefined || _this._accessoryInfo.setupID === "") {
                _this._setupID = _this._generateSetupID();
            }
            else {
                _this._setupID = _this._accessoryInfo.setupID;
            }
            _this._accessoryInfo.setupID = _this._setupID;
            // make sure we have up-to-date values in AccessoryInfo, then save it in case they changed (or if we just created it)
            _this._accessoryInfo.displayName = _this.displayName;
            _this._accessoryInfo.category = info.category || Categories.OTHER;
            _this._accessoryInfo.pincode = info.pincode;
            _this._accessoryInfo.save();
            // if (this._isBridge) {
            //   this.relayServer = new RelayServer(this._accessoryInfo);
            //   this.addService(this.relayServer.relayService());
            // }
            // create our IdentifierCache so we can provide clients with stable aid/iid's
            _this._identifierCache = IdentifierCache_1.IdentifierCache.load(info.username);
            // if we don't have one, create a new one.
            if (!_this._identifierCache) {
                debug("[%s] Creating new IdentifierCache", _this.displayName);
                _this._identifierCache = new IdentifierCache_1.IdentifierCache(info.username);
            }
            //If it's bridge and there are not accessories already assigned to the bridge
            //probably purge is not needed since it's going to delete all the ids
            //of accessories that might be added later. Usefull when dynamically adding
            //accessories.
            if (_this._isBridge && _this.bridgedAccessories.length == 0)
                _this.disableUnusedIDPurge();
            // assign aid/iid
            _this._assignIDs(_this._identifierCache);
            // get our accessory information in HAP format and determine if our configuration (that is, our
            // Accessories/Services/Characteristics) has changed since the last time we were published. make
            // sure to omit actual values since these are not part of the "configuration".
            var config = _this.toHAP({ omitValues: true });
            // now convert it into a hash code and check it against the last one we made, if we have one
            var shasum = crypto_1.default.createHash('sha1');
            shasum.update(JSON.stringify(config));
            var configHash = shasum.digest('hex');
            if (configHash !== _this._accessoryInfo.configHash) {
                // our configuration has changed! we'll need to bump our config version number
                _this._accessoryInfo.configVersion++;
                _this._accessoryInfo.configHash = configHash;
                _this._accessoryInfo.save();
            }
            // create our Advertiser which broadcasts our presence over mdns
            _this._advertiser = new Advertiser_1.Advertiser(_this._accessoryInfo, info.mdns);
            // create our HAP server which handles all communication between iOS devices and us
            _this._server = new HAPServer_1.HAPServer(_this._accessoryInfo, _this.relayServer);
            _this._server.allowInsecureRequest = !!allowInsecureRequest;
            _this._server.on(HAPServer_1.HAPServerEventTypes.LISTENING, _this._onListening);
            _this._server.on(HAPServer_1.HAPServerEventTypes.IDENTIFY, _this._handleIdentify);
            _this._server.on(HAPServer_1.HAPServerEventTypes.PAIR, _this._handlePair);
            _this._server.on(HAPServer_1.HAPServerEventTypes.ADD_PAIRING, _this._handleAddPairing);
            _this._server.on(HAPServer_1.HAPServerEventTypes.REMOVE_PAIRING, _this._handleRemovePairing);
            _this._server.on(HAPServer_1.HAPServerEventTypes.LIST_PAIRINGS, _this._handleListPairings);
            _this._server.on(HAPServer_1.HAPServerEventTypes.ACCESSORIES, _this._handleAccessories);
            _this._server.on(HAPServer_1.HAPServerEventTypes.GET_CHARACTERISTICS, _this._handleGetCharacteristics);
            _this._server.on(HAPServer_1.HAPServerEventTypes.SET_CHARACTERISTICS, _this._handleSetCharacteristics);
            _this._server.on(HAPServer_1.HAPServerEventTypes.SESSION_CLOSE, _this._handleSessionClose);
            _this._server.on(HAPServer_1.HAPServerEventTypes.REQUEST_RESOURCE, _this._handleResource);
            var targetPort = info.port || 0;
            _this._server.listen(targetPort);
        };
        /**
         * Removes this Accessory from the local network
         * Accessory object will no longer vaild after invoking this method
         * Trying to invoke publish() on the object will result undefined behavior
         */
        _this.destroy = function () {
            _this.unpublish();
            if (_this._accessoryInfo) {
                _this._accessoryInfo.remove();
                _this._accessoryInfo = undefined;
            }
            if (_this._identifierCache) {
                _this._identifierCache.remove();
                _this._identifierCache = undefined;
            }
        };
        _this.unpublish = function () {
            if (_this._server) {
                _this._server.stop();
                _this._server = undefined;
            }
            if (_this._advertiser) {
                _this._advertiser.stopAdvertising();
                _this._advertiser = undefined;
            }
        };
        _this._updateConfiguration = function () {
            if (_this._advertiser && _this._advertiser.isAdvertising()) {
                // get our accessory information in HAP format and determine if our configuration (that is, our
                // Accessories/Services/Characteristics) has changed since the last time we were published. make
                // sure to omit actual values since these are not part of the "configuration".
                var config = _this.toHAP({ omitValues: true });
                // now convert it into a hash code and check it against the last one we made, if we have one
                var shasum = crypto_1.default.createHash('sha1');
                shasum.update(JSON.stringify(config));
                var configHash = shasum.digest('hex');
                if (_this._accessoryInfo && configHash !== _this._accessoryInfo.configHash) {
                    // our configuration has changed! we'll need to bump our config version number
                    _this._accessoryInfo.configVersion++;
                    _this._accessoryInfo.configHash = configHash;
                    _this._accessoryInfo.save();
                }
                // update our advertisement so HomeKit on iOS can pickup new accessory
                _this._advertiser.updateAdvertisement();
            }
        };
        _this._onListening = function (port) {
            // the HAP server is listening, so we can now start advertising our presence.
            _this._advertiser && _this._advertiser.startAdvertising(port);
            _this.emit(AccessoryEventTypes.LISTENING, port);
        };
        // Called when an unpaired client wishes for us to identify ourself
        _this._handleIdentify = function (callback) {
            var paired = false;
            _this._identificationRequest(paired, callback);
        };
        // Called when HAPServer has completed the pairing process with a client
        _this._handlePair = function (username, publicKey, callback) {
            debug("[%s] Paired with client %s", _this.displayName, username);
            _this._accessoryInfo && _this._accessoryInfo.addPairedClient(username, publicKey, AccessoryInfo_1.PermissionTypes.ADMIN);
            _this._accessoryInfo && _this._accessoryInfo.save();
            // update our advertisement so it can pick up on the paired status of AccessoryInfo
            _this._advertiser && _this._advertiser.updateAdvertisement();
            callback();
            _this.emit(AccessoryEventTypes.PAIRED);
        };
        // called when a controller adds an additional pairing
        _this._handleAddPairing = function (controller, username, publicKey, permission, callback) {
            if (!_this._accessoryInfo) {
                callback(HAPServer_1.Codes.UNAVAILABLE);
                return;
            }
            if (!_this._accessoryInfo.hasAdminPermissions(controller.username)) {
                callback(HAPServer_1.Codes.AUTHENTICATION);
                return;
            }
            var existingKey = _this._accessoryInfo.getClientPublicKey(username);
            if (existingKey) {
                if (existingKey.toString() !== publicKey.toString()) {
                    callback(HAPServer_1.Codes.UNKNOWN);
                    return;
                }
                _this._accessoryInfo.updatePermission(username, permission);
            }
            else {
                _this._accessoryInfo.addPairedClient(username, publicKey, permission);
            }
            _this._accessoryInfo.save();
            // there should be no need to update advertisement
            callback(0);
        };
        _this._handleRemovePairing = function (controller, username, callback) {
            if (!_this._accessoryInfo) {
                callback(HAPServer_1.Codes.UNAVAILABLE);
                return;
            }
            if (!_this._accessoryInfo.hasAdminPermissions(controller.username)) {
                callback(HAPServer_1.Codes.AUTHENTICATION);
                return;
            }
            _this._accessoryInfo.removePairedClient(controller, username);
            _this._accessoryInfo.save();
            if (!_this._accessoryInfo.paired()) {
                _this._advertiser && _this._advertiser.updateAdvertisement();
                _this.emit(AccessoryEventTypes.UNPAIRED);
            }
            callback(0);
        };
        _this._handleListPairings = function (controller, callback) {
            if (!_this._accessoryInfo) {
                callback(HAPServer_1.Codes.UNAVAILABLE);
                return;
            }
            if (!_this._accessoryInfo.hasAdminPermissions(controller.username)) {
                callback(HAPServer_1.Codes.AUTHENTICATION);
                return;
            }
            callback(0, _this._accessoryInfo.listPairings());
        };
        // Called when an iOS client wishes to know all about our accessory via JSON payload
        _this._handleAccessories = function (callback) {
            // make sure our aid/iid's are all assigned
            _this._assignIDs(_this._identifierCache);
            // build out our JSON payload and call the callback
            callback(null, {
                accessories: _this.toHAP() // array of Accessory HAP
            });
        };
        // Called when an iOS client wishes to query the state of one or more characteristics, like "door open?", "light on?", etc.
        _this._handleGetCharacteristics = function (data, events, callback, remote, session) {
            // build up our array of responses to the characteristics requested asynchronously
            var characteristics = [];
            var statusKey = remote ? 's' : 'status';
            var valueKey = remote ? 'v' : 'value';
            data.forEach(function (characteristicData) {
                var aid = characteristicData.aid;
                var iid = characteristicData.iid;
                var includeEvent = characteristicData.e;
                var characteristic = _this.findCharacteristic(characteristicData.aid, characteristicData.iid);
                if (!characteristic) {
                    debug('[%s] Could not find a Characteristic with iid of %s and aid of %s', _this.displayName, characteristicData.aid, characteristicData.iid);
                    var response = {
                        aid: aid,
                        iid: iid
                    };
                    response[statusKey] = HAPServer_1.Status.SERVICE_COMMUNICATION_FAILURE; // generic error status
                    characteristics.push(response);
                    // have we collected all responses yet?
                    if (characteristics.length === data.length)
                        callback(null, characteristics);
                    return;
                }
                if (!characteristic.props.perms.includes(Characteristic_1.Perms.PAIRED_READ)) { // check if we are allowed to read from this characteristic
                    debug('[%s] Tried reading from Characteristic which does not allow reading (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                    var response_1 = {
                        aid: aid,
                        iid: iid
                    };
                    response_1[statusKey] = HAPServer_1.Status.WRITE_ONLY_CHARACTERISTIC;
                    characteristics.push(response_1);
                    if (characteristics.length === data.length) {
                        callback(null, characteristics);
                    }
                    return;
                }
                if (characteristic.accessRestrictedToAdmins.includes(Characteristic_1.Access.READ)) {
                    var verifiable = true;
                    if (!session || !session.username || !_this._accessoryInfo) {
                        verifiable = false;
                        debug('[%s] Could not verify admin permissions for Characteristic which requires admin permissions for reading (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                    }
                    if (!verifiable || !_this._accessoryInfo.hasAdminPermissions(session.username)) {
                        var response_2 = {
                            aid: aid,
                            iid: iid
                        };
                        response_2[statusKey] = HAPServer_1.Status.INSUFFICIENT_PRIVILEGES;
                        characteristics.push(response_2);
                        if (characteristics.length === data.length)
                            callback(null, characteristics);
                        return;
                    }
                }
                // Found the Characteristic! Get the value!
                debug('[%s] Getting value for Characteristic "%s"', _this.displayName, characteristic.displayName);
                // we want to remember "who" made this request, so that we don't send them an event notification
                // about any changes that occurred as a result of the request. For instance, if after querying
                // the current value of a characteristic, the value turns out to be different than the previously
                // cached Characteristic value, an internal 'change' event will be emitted which will cause us to
                // notify all connected clients about that new value. But this client is about to get the new value
                // anyway, so we don't want to notify it twice.
                var context = events;
                // set the value and wait for success
                characteristic.getValue(function (err, value) {
                    debug('[%s] Got Characteristic "%s" value: %s', _this.displayName, characteristic.displayName, value);
                    if (err) {
                        debug('[%s] Error getting value for Characteristic "%s": %s', _this.displayName, characteristic.displayName, err.message);
                        var response = {
                            aid: aid,
                            iid: iid
                        };
                        response[statusKey] = hapStatus(err);
                        characteristics.push(response);
                    }
                    else {
                        var response = {
                            aid: aid,
                            iid: iid
                        };
                        response[valueKey] = value;
                        if (includeEvent) {
                            var eventName = aid + '.' + iid;
                            response['e'] = (events[eventName] === true);
                        }
                        // compose the response and add it to the list
                        characteristics.push(response);
                    }
                    // have we collected all responses yet?
                    if (characteristics.length === data.length)
                        callback(null, characteristics);
                }, context, session ? session.sessionID : undefined);
            });
        };
        // Called when an iOS client wishes to change the state of this accessory - like opening a door, or turning on a light.
        // Or, to subscribe to change events for a particular Characteristic.
        _this._handleSetCharacteristics = function (writeRequest, events, callback, remote, session) {
            var data = writeRequest.characteristics;
            // data is an array of characteristics and values like this:
            // [ { aid: 1, iid: 8, value: true, ev: true } ]
            debug("[%s] Processing characteristic set: %s", _this.displayName, JSON.stringify(data));
            var writeState = WriteRequestState.REGULAR_REQUEST;
            if (writeRequest.pid !== undefined) { // check for timed writes
                if (session.timedWritePid === writeRequest.pid) {
                    writeState = WriteRequestState.TIMED_WRITE_AUTHENTICATED;
                    clearTimeout(session.timedWriteTimeout);
                    session.timedWritePid = undefined;
                    session.timedWriteTimeout = undefined;
                    debug("[%s] Timed write request got acknowledged for pid %d", _this.displayName, writeRequest.pid);
                }
                else {
                    writeState = WriteRequestState.TIMED_WRITE_REJECTED;
                    debug("[%s] TTL for timed write request has probably expired for pid %d", _this.displayName, writeRequest.pid);
                }
            }
            // build up our array of responses to the characteristics requested asynchronously
            var characteristics = [];
            data.forEach(function (characteristicData) {
                var aid = characteristicData.aid;
                var iid = characteristicData.iid;
                var value = remote ? characteristicData.v : characteristicData.value;
                var ev = remote ? characteristicData.e : characteristicData.ev;
                var includeValue = characteristicData.r || false;
                var statusKey = remote ? 's' : 'status';
                var characteristic = _this.findCharacteristic(aid, iid);
                if (!characteristic) {
                    debug('[%s] Could not find a Characteristic with iid of %s and aid of %s', _this.displayName, characteristicData.aid, characteristicData.iid);
                    var response = {
                        aid: aid,
                        iid: iid
                    };
                    response[statusKey] = HAPServer_1.Status.SERVICE_COMMUNICATION_FAILURE; // generic error status
                    characteristics.push(response);
                    // have we collected all responses yet?
                    if (characteristics.length === data.length)
                        callback(null, characteristics);
                    return;
                }
                if (writeState === WriteRequestState.TIMED_WRITE_REJECTED) {
                    var response_3 = {
                        aid: aid,
                        iid: iid
                    };
                    response_3[statusKey] = HAPServer_1.Status.INVALID_VALUE_IN_REQUEST;
                    characteristics.push(response_3);
                    if (characteristics.length === data.length)
                        callback(null, characteristics);
                    return;
                }
                // we want to remember "who" initiated this change, so that we don't send them an event notification
                // about the change they just made. We do this by leveraging the arbitrary "context" object supported
                // by Characteristic and passed on to the corresponding 'change' events bubbled up from Characteristic
                // through Service and Accessory. We'll assign it to the events object since it essentially represents
                // the connection requesting the change.
                var context = events;
                // if "ev" is present, that means we need to register or unregister this client for change events for
                // this characteristic.
                if (typeof ev !== 'undefined') {
                    if (!characteristic.props.perms.includes(Characteristic_1.Perms.NOTIFY)) { // check if notify is allowed for this characteristic
                        debug('[%s] Tried enabling notifications for Characteristic which does not allow notify (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                        var response_4 = {
                            aid: aid,
                            iid: iid
                        };
                        response_4[statusKey] = HAPServer_1.Status.NOTIFICATION_NOT_SUPPORTED;
                        characteristics.push(response_4);
                        if (characteristics.length === data.length) {
                            callback(null, characteristics);
                        }
                        return;
                    }
                    if (characteristic.accessRestrictedToAdmins.includes(Characteristic_1.Access.NOTIFY)) {
                        var verifiable = true;
                        if (!session || !session.username || !_this._accessoryInfo) {
                            verifiable = false;
                            debug('[%s] Could not verify admin permissions for Characteristic which requires admin permissions for notify (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                        }
                        if (!verifiable || !_this._accessoryInfo.hasAdminPermissions(session.username)) {
                            var response_5 = {
                                aid: aid,
                                iid: iid
                            };
                            response_5[statusKey] = HAPServer_1.Status.INSUFFICIENT_PRIVILEGES;
                            characteristics.push(response_5);
                            if (characteristics.length === data.length)
                                callback(null, characteristics);
                            return;
                        }
                    }
                    debug('[%s] %s Characteristic "%s" for events', _this.displayName, ev ? "Registering" : "Unregistering", characteristic.displayName);
                    // store event registrations in the supplied "events" dict which is associated with the connection making
                    // the request.
                    var eventName = aid + '.' + iid;
                    if (ev === true && events[eventName] != true) {
                        events[eventName] = true; // value is arbitrary, just needs to be non-falsey
                        characteristic.subscribe();
                    }
                    if (ev === false && events[eventName] != undefined) {
                        characteristic.unsubscribe();
                        delete events[eventName]; // unsubscribe by deleting name from dict
                    }
                }
                // Found the characteristic - set the value if there is one
                if (typeof value !== 'undefined') {
                    if (!characteristic.props.perms.includes(Characteristic_1.Perms.PAIRED_WRITE)) { // check if write is allowed for this characteristic
                        debug('[%s] Tried writing to Characteristic which does not allow writing (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                        var response_6 = {
                            aid: aid,
                            iid: iid
                        };
                        response_6[statusKey] = HAPServer_1.Status.READ_ONLY_CHARACTERISTIC;
                        characteristics.push(response_6);
                        if (characteristics.length === data.length) {
                            callback(null, characteristics);
                        }
                        return;
                    }
                    if (characteristic.accessRestrictedToAdmins.includes(Characteristic_1.Access.WRITE)) {
                        var verifiable = true;
                        if (!session || !session.username || !_this._accessoryInfo) {
                            verifiable = false;
                            debug('[%s] Could not verify admin permissions for Characteristic which requires admin permissions for write (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                        }
                        if (!verifiable || !_this._accessoryInfo.hasAdminPermissions(session.username)) {
                            var response_7 = {
                                aid: aid,
                                iid: iid
                            };
                            response_7[statusKey] = HAPServer_1.Status.INSUFFICIENT_PRIVILEGES;
                            characteristics.push(response_7);
                            if (characteristics.length === data.length)
                                callback(null, characteristics);
                            return;
                        }
                    }
                    if (characteristic.props.perms.includes(Characteristic_1.Perms.TIMED_WRITE) && writeState !== WriteRequestState.TIMED_WRITE_AUTHENTICATED) {
                        debug('[%s] Tried writing to a timed write only Characteristic without properly preparing (iid of %s and aid of %s)', _this.displayName, characteristicData.aid, characteristicData.iid);
                        var response_8 = {
                            aid: aid,
                            iid: iid
                        };
                        response_8[statusKey] = HAPServer_1.Status.INVALID_VALUE_IN_REQUEST;
                        characteristics.push(response_8);
                        if (characteristics.length === data.length)
                            callback(null, characteristics);
                        return;
                    }
                    debug('[%s] Setting Characteristic "%s" to value %s', _this.displayName, characteristic.displayName, value);
                    // set the value and wait for success
                    characteristic.setValue(value, function (err) {
                        if (err) {
                            debug('[%s] Error setting Characteristic "%s" to value %s: ', _this.displayName, characteristic.displayName, value, err.message);
                            var response = {
                                aid: aid,
                                iid: iid
                            };
                            response[statusKey] = hapStatus(err);
                            characteristics.push(response);
                        }
                        else {
                            var response = {
                                aid: aid,
                                iid: iid
                            };
                            response[statusKey] = 0;
                            if (includeValue)
                                response['value'] = characteristic.value;
                            characteristics.push(response);
                        }
                        // have we collected all responses yet?
                        if (characteristics.length === data.length)
                            callback(null, characteristics);
                    }, context, session ? session.sessionID : undefined);
                }
                else {
                    // no value to set, so we're done (success)
                    var response = {
                        aid: aid,
                        iid: iid
                    };
                    response[statusKey] = 0;
                    characteristics.push(response);
                    // have we collected all responses yet?
                    if (characteristics.length === data.length)
                        callback(null, characteristics);
                }
            });
        };
        _this._handleResource = function (data, callback) {
            if (data["resource-type"] == ResourceTypes.IMAGE) {
                var aid = data["aid"]; // aid is optionally supplied by HomeKit (for example when camera is bridged, multiple cams, etc)
                var cameraSource = void 0;
                if (aid) {
                    if (_this.aid === aid && _this.cameraSource) { // bridge is probably not a camera but it is theoretically possible
                        cameraSource = _this.cameraSource;
                    }
                    else {
                        var accessory = _this.getBridgedAccessoryByAID(aid);
                        if (accessory && accessory.cameraSource) {
                            cameraSource = accessory.cameraSource;
                        }
                    }
                }
                else if (_this.cameraSource) { // aid was not supplied, check if this accessory is a camera
                    cameraSource = _this.cameraSource;
                }
                if (!cameraSource) {
                    callback(new Error("resource not found"));
                    return;
                }
                cameraSource.handleSnapshotRequest({
                    width: data["image-width"],
                    height: data["image-height"]
                }, callback);
                return;
            }
            callback(new Error('unsupported image type: ' + data["resource-type"]));
        };
        _this._handleSessionClose = function (sessionID, events) {
            if (_this.cameraSource && _this.cameraSource.handleCloseConnection) {
                _this.cameraSource.handleCloseConnection(sessionID);
            }
            _this._unsubscribeEvents(events);
        };
        _this._unsubscribeEvents = function (events) {
            for (var key in events) {
                if (key.indexOf('.') !== -1) {
                    try {
                        var id = key.split('.');
                        var aid = Number.parseInt(id[0]);
                        var iid = Number.parseInt(id[1]);
                        var characteristic = _this.findCharacteristic(aid, iid);
                        if (characteristic) {
                            characteristic.unsubscribe();
                        }
                    }
                    catch (e) {
                    }
                }
            }
        };
        // Called internally above when a change was detected in one of our hosted Characteristics somewhere in our hierarchy.
        _this._handleCharacteristicChange = function (change) {
            if (!_this._server)
                return; // we're not running a HAPServer, so there's no one to notify about this event
            var data = {
                characteristics: [{
                        aid: change.accessory.aid,
                        iid: change.characteristic.iid,
                        value: change.newValue
                    }]
            };
            // name for this event that corresponds to what we stored when the client signed up (in handleSetCharacteristics)
            var eventName = change.accessory.aid + '.' + change.characteristic.iid;
            // pull the events object associated with the original connection (if any) that initiated the change request,
            // which we assigned in handleGetCharacteristics/handleSetCharacteristics.
            var excludeEvents = change.context;
            // pass it along to notifyClients() so that it can omit the connection where events === excludeEvents.
            _this._server.notifyClients(eventName, data, excludeEvents);
        };
        _this._setupService = function (service) {
            service.on(Service_1.ServiceEventTypes.SERVICE_CONFIGURATION_CHANGE, function () {
                if (!_this.bridged) {
                    _this._updateConfiguration();
                }
                else {
                    _this.emit(AccessoryEventTypes.SERVICE_CONFIGURATION_CHANGE, clone_1.clone({ accessory: _this, service: service }));
                }
            });
            // listen for changes in characteristics and bubble them up
            service.on(Service_1.ServiceEventTypes.CHARACTERISTIC_CHANGE, function (change) {
                _this.emit(AccessoryEventTypes.SERVICE_CHARACTERISTIC_CHANGE, clone_1.clone(change, { service: service }));
                // if we're not bridged, when we'll want to process this event through our HAPServer
                if (!_this.bridged)
                    _this._handleCharacteristicChange(clone_1.clone(change, { accessory: _this, service: service }));
            });
        };
        _this._sideloadServices = function (targetServices) {
            for (var index in targetServices) {
                var target = targetServices[index];
                _this._setupService(target);
            }
            _this.services = targetServices.slice();
            // Fix Identify
            _this
                .getService(Service_1.Service.AccessoryInformation)
                .getCharacteristic(Characteristic_1.Characteristic.Identify)
                .on(Characteristic_1.CharacteristicEventTypes.SET, function (value, callback) {
                if (value) {
                    var paired = true;
                    _this._identificationRequest(paired, callback);
                }
            });
        };
        _this._generateSetupID = function () {
            var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var bytes = crypto_1.default.randomBytes(4);
            var setupID = '';
            for (var i = 0; i < 4; i++) {
                var index = bytes.readUInt8(i) % 26;
                setupID += chars.charAt(index);
            }
            return setupID;
        };
        if (!displayName)
            throw new Error("Accessories must be created with a non-empty displayName.");
        if (!UUID)
            throw new Error("Accessories must be created with a valid UUID.");
        if (!uuid.isValid(UUID))
            throw new Error("UUID '" + UUID + "' is not a valid UUID. Try using the provided 'generateUUID' function to create a valid UUID from any arbitrary string, like a serial number.");
        // create our initial "Accessory Information" Service that all Accessories are expected to have
        _this
            .addService(Service_1.Service.AccessoryInformation)
            .setCharacteristic(Characteristic_1.Characteristic.Name, displayName)
            .setCharacteristic(Characteristic_1.Characteristic.Manufacturer, "Default-Manufacturer")
            .setCharacteristic(Characteristic_1.Characteristic.Model, "Default-Model")
            .setCharacteristic(Characteristic_1.Characteristic.SerialNumber, "Default-SerialNumber")
            .setCharacteristic(Characteristic_1.Characteristic.FirmwareRevision, "1.0");
        // sign up for when iOS attempts to "set" the Identify characteristic - this means a paired device wishes
        // for us to identify ourselves (as opposed to an unpaired device - that case is handled by HAPServer 'identify' event)
        _this.getService(Service_1.Service.AccessoryInformation)
            .getCharacteristic(Characteristic_1.Characteristic.Identify)
            .on(Characteristic_1.CharacteristicEventTypes.SET, function (value, callback) {
            if (value) {
                var paired = true;
                _this._identificationRequest(paired, callback);
            }
        });
        return _this;
    }
    Accessory.Categories = Categories;
    // serialization and deserialization functions, mainly designed for homebridge to create a json copy to store on disk
    Accessory.serialize = function (accessory) {
        var json = {
            displayName: accessory.displayName,
            UUID: accessory.UUID,
            category: accessory.category,
            services: [],
        };
        var linkedServices = {};
        var hasLinkedServices = false;
        accessory.services.forEach(function (service) {
            json.services.push(Service_1.Service.serialize(service));
            var linkedServicesPresentation = [];
            service.linkedServices.forEach(function (linkedService) {
                linkedServicesPresentation.push(linkedService.UUID + (linkedService.subtype || ""));
            });
            if (linkedServicesPresentation.length > 0) {
                linkedServices[service.UUID + (service.subtype || "")] = linkedServicesPresentation;
                hasLinkedServices = true;
            }
        });
        if (hasLinkedServices) {
            json.linkedServices = linkedServices;
        }
        return json;
    };
    Accessory.deserialize = function (json) {
        var accessory = new Accessory(json.displayName, json.UUID);
        accessory.category = json.category;
        var services = [];
        var servicesMap = {};
        json.services.forEach(function (serialized) {
            var service = Service_1.Service.deserialize(serialized);
            services.push(service);
            servicesMap[service.UUID + (service.subtype || "")] = service;
        });
        if (json.linkedServices) {
            var _loop_1 = function (serviceId) {
                var primaryService = servicesMap[serviceId];
                var linkedServicesKeys = json.linkedServices[serviceId];
                if (!primaryService) {
                    return "continue";
                }
                linkedServicesKeys.forEach(function (linkedServiceKey) {
                    var linkedService = servicesMap[linkedServiceKey];
                    if (linkedService) {
                        primaryService.addLinkedService(linkedService);
                    }
                });
            };
            for (var serviceId in json.linkedServices) {
                _loop_1(serviceId);
            }
        }
        accessory._sideloadServices(services);
        return accessory;
    };
    return Accessory;
}(EventEmitter_1.EventEmitter));
exports.Accessory = Accessory;
function hapStatus(err) {
    // Validate that the message is a valid HAPServer.Status
    var value = 0; // default if not found or
    for (var k in HAPServer_1.Status) {
        if (HAPServer_1.Status[k] == err.message) {
            value = err.message;
            break;
        }
    }
    if (value == 0)
        value = HAPServer_1.Status.SERVICE_COMMUNICATION_FAILURE; // default if not found or 0
    return (parseInt("" + value));
}
//# sourceMappingURL=Accessory.js.map